// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: operation_msg.proto

#ifndef PROTOBUF_operation_5fmsg_2eproto__INCLUDED
#define PROTOBUF_operation_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace operation_msg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_operation_5fmsg_2eproto();
void protobuf_AssignDesc_operation_5fmsg_2eproto();
void protobuf_ShutdownFile_operation_5fmsg_2eproto();

class Response;
class Operation;
class Operation_Init;
class Operation_TransactionBegin;
class Operation_TransactionEnd;
class Operation_NoticeError;

enum Operation_OperationType {
  Operation_OperationType_INIT = 1,
  Operation_OperationType_TRANSACTION_BEGIN = 2,
  Operation_OperationType_TRANSACTION_END = 3,
  Operation_OperationType_TRANSACTION_NOTICE_ERROR = 4
};
bool Operation_OperationType_IsValid(int value);
const Operation_OperationType Operation_OperationType_OperationType_MIN = Operation_OperationType_INIT;
const Operation_OperationType Operation_OperationType_OperationType_MAX = Operation_OperationType_TRANSACTION_NOTICE_ERROR;
const int Operation_OperationType_OperationType_ARRAYSIZE = Operation_OperationType_OperationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Operation_OperationType_descriptor();
inline const ::std::string& Operation_OperationType_Name(Operation_OperationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Operation_OperationType_descriptor(), value);
}
inline bool Operation_OperationType_Parse(
    const ::std::string& name, Operation_OperationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Operation_OperationType>(
    Operation_OperationType_descriptor(), name, value);
}
// ===================================================================

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool error = 1;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 1;
  inline bool error() const;
  inline void set_error(bool value);

  // required int32 code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // optional uint64 transaction_id = 3;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 3;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:operation_msg.Response)
 private:
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool error_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::uint64 transaction_id_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// -------------------------------------------------------------------

class Operation_Init : public ::google::protobuf::Message {
 public:
  Operation_Init();
  virtual ~Operation_Init();

  Operation_Init(const Operation_Init& from);

  inline Operation_Init& operator=(const Operation_Init& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation_Init& default_instance();

  void Swap(Operation_Init* other);

  // implements Message ----------------------------------------------

  Operation_Init* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation_Init& from);
  void MergeFrom(const Operation_Init& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string license = 1;
  inline bool has_license() const;
  inline void clear_license();
  static const int kLicenseFieldNumber = 1;
  inline const ::std::string& license() const;
  inline void set_license(const ::std::string& value);
  inline void set_license(const char* value);
  inline void set_license(const char* value, size_t size);
  inline ::std::string* mutable_license();
  inline ::std::string* release_license();
  inline void set_allocated_license(::std::string* license);

  // required string app_name = 2;
  inline bool has_app_name() const;
  inline void clear_app_name();
  static const int kAppNameFieldNumber = 2;
  inline const ::std::string& app_name() const;
  inline void set_app_name(const ::std::string& value);
  inline void set_app_name(const char* value);
  inline void set_app_name(const char* value, size_t size);
  inline ::std::string* mutable_app_name();
  inline ::std::string* release_app_name();
  inline void set_allocated_app_name(::std::string* app_name);

  // required string language = 3;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 3;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // required string language_version = 4;
  inline bool has_language_version() const;
  inline void clear_language_version();
  static const int kLanguageVersionFieldNumber = 4;
  inline const ::std::string& language_version() const;
  inline void set_language_version(const ::std::string& value);
  inline void set_language_version(const char* value);
  inline void set_language_version(const char* value, size_t size);
  inline ::std::string* mutable_language_version();
  inline ::std::string* release_language_version();
  inline void set_allocated_language_version(::std::string* language_version);

  // @@protoc_insertion_point(class_scope:operation_msg.Operation.Init)
 private:
  inline void set_has_license();
  inline void clear_has_license();
  inline void set_has_app_name();
  inline void clear_has_app_name();
  inline void set_has_language();
  inline void clear_has_language();
  inline void set_has_language_version();
  inline void clear_has_language_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* license_;
  ::std::string* app_name_;
  ::std::string* language_;
  ::std::string* language_version_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Operation_Init* default_instance_;
};
// -------------------------------------------------------------------

class Operation_TransactionBegin : public ::google::protobuf::Message {
 public:
  Operation_TransactionBegin();
  virtual ~Operation_TransactionBegin();

  Operation_TransactionBegin(const Operation_TransactionBegin& from);

  inline Operation_TransactionBegin& operator=(const Operation_TransactionBegin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation_TransactionBegin& default_instance();

  void Swap(Operation_TransactionBegin* other);

  // implements Message ----------------------------------------------

  Operation_TransactionBegin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation_TransactionBegin& from);
  void MergeFrom(const Operation_TransactionBegin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:operation_msg.Operation.TransactionBegin)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Operation_TransactionBegin* default_instance_;
};
// -------------------------------------------------------------------

class Operation_TransactionEnd : public ::google::protobuf::Message {
 public:
  Operation_TransactionEnd();
  virtual ~Operation_TransactionEnd();

  Operation_TransactionEnd(const Operation_TransactionEnd& from);

  inline Operation_TransactionEnd& operator=(const Operation_TransactionEnd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation_TransactionEnd& default_instance();

  void Swap(Operation_TransactionEnd* other);

  // implements Message ----------------------------------------------

  Operation_TransactionEnd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation_TransactionEnd& from);
  void MergeFrom(const Operation_TransactionEnd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:operation_msg.Operation.TransactionEnd)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 transaction_id_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Operation_TransactionEnd* default_instance_;
};
// -------------------------------------------------------------------

class Operation_NoticeError : public ::google::protobuf::Message {
 public:
  Operation_NoticeError();
  virtual ~Operation_NoticeError();

  Operation_NoticeError(const Operation_NoticeError& from);

  inline Operation_NoticeError& operator=(const Operation_NoticeError& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation_NoticeError& default_instance();

  void Swap(Operation_NoticeError* other);

  // implements Message ----------------------------------------------

  Operation_NoticeError* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation_NoticeError& from);
  void MergeFrom(const Operation_NoticeError& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 transaction_id = 1;
  inline bool has_transaction_id() const;
  inline void clear_transaction_id();
  static const int kTransactionIdFieldNumber = 1;
  inline ::google::protobuf::uint64 transaction_id() const;
  inline void set_transaction_id(::google::protobuf::uint64 value);

  // required string exception_type = 2;
  inline bool has_exception_type() const;
  inline void clear_exception_type();
  static const int kExceptionTypeFieldNumber = 2;
  inline const ::std::string& exception_type() const;
  inline void set_exception_type(const ::std::string& value);
  inline void set_exception_type(const char* value);
  inline void set_exception_type(const char* value, size_t size);
  inline ::std::string* mutable_exception_type();
  inline ::std::string* release_exception_type();
  inline void set_allocated_exception_type(::std::string* exception_type);

  // required string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // required string stack_trace = 4;
  inline bool has_stack_trace() const;
  inline void clear_stack_trace();
  static const int kStackTraceFieldNumber = 4;
  inline const ::std::string& stack_trace() const;
  inline void set_stack_trace(const ::std::string& value);
  inline void set_stack_trace(const char* value);
  inline void set_stack_trace(const char* value, size_t size);
  inline ::std::string* mutable_stack_trace();
  inline ::std::string* release_stack_trace();
  inline void set_allocated_stack_trace(::std::string* stack_trace);

  // required string stack_frame_delimiter = 5;
  inline bool has_stack_frame_delimiter() const;
  inline void clear_stack_frame_delimiter();
  static const int kStackFrameDelimiterFieldNumber = 5;
  inline const ::std::string& stack_frame_delimiter() const;
  inline void set_stack_frame_delimiter(const ::std::string& value);
  inline void set_stack_frame_delimiter(const char* value);
  inline void set_stack_frame_delimiter(const char* value, size_t size);
  inline ::std::string* mutable_stack_frame_delimiter();
  inline ::std::string* release_stack_frame_delimiter();
  inline void set_allocated_stack_frame_delimiter(::std::string* stack_frame_delimiter);

  // @@protoc_insertion_point(class_scope:operation_msg.Operation.NoticeError)
 private:
  inline void set_has_transaction_id();
  inline void clear_has_transaction_id();
  inline void set_has_exception_type();
  inline void clear_has_exception_type();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_stack_trace();
  inline void clear_has_stack_trace();
  inline void set_has_stack_frame_delimiter();
  inline void clear_has_stack_frame_delimiter();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 transaction_id_;
  ::std::string* exception_type_;
  ::std::string* error_message_;
  ::std::string* stack_trace_;
  ::std::string* stack_frame_delimiter_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Operation_NoticeError* default_instance_;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  void Swap(Operation* other);

  // implements Message ----------------------------------------------

  Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Operation_Init Init;
  typedef Operation_TransactionBegin TransactionBegin;
  typedef Operation_TransactionEnd TransactionEnd;
  typedef Operation_NoticeError NoticeError;

  typedef Operation_OperationType OperationType;
  static const OperationType INIT = Operation_OperationType_INIT;
  static const OperationType TRANSACTION_BEGIN = Operation_OperationType_TRANSACTION_BEGIN;
  static const OperationType TRANSACTION_END = Operation_OperationType_TRANSACTION_END;
  static const OperationType TRANSACTION_NOTICE_ERROR = Operation_OperationType_TRANSACTION_NOTICE_ERROR;
  static inline bool OperationType_IsValid(int value) {
    return Operation_OperationType_IsValid(value);
  }
  static const OperationType OperationType_MIN =
    Operation_OperationType_OperationType_MIN;
  static const OperationType OperationType_MAX =
    Operation_OperationType_OperationType_MAX;
  static const int OperationType_ARRAYSIZE =
    Operation_OperationType_OperationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OperationType_descriptor() {
    return Operation_OperationType_descriptor();
  }
  static inline const ::std::string& OperationType_Name(OperationType value) {
    return Operation_OperationType_Name(value);
  }
  static inline bool OperationType_Parse(const ::std::string& name,
      OperationType* value) {
    return Operation_OperationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .operation_msg.Operation.OperationType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::operation_msg::Operation_OperationType type() const;
  inline void set_type(::operation_msg::Operation_OperationType value);

  // optional .operation_msg.Operation.Init init = 2;
  inline bool has_init() const;
  inline void clear_init();
  static const int kInitFieldNumber = 2;
  inline const ::operation_msg::Operation_Init& init() const;
  inline ::operation_msg::Operation_Init* mutable_init();
  inline ::operation_msg::Operation_Init* release_init();
  inline void set_allocated_init(::operation_msg::Operation_Init* init);

  // optional .operation_msg.Operation.TransactionBegin transaction_begin = 3;
  inline bool has_transaction_begin() const;
  inline void clear_transaction_begin();
  static const int kTransactionBeginFieldNumber = 3;
  inline const ::operation_msg::Operation_TransactionBegin& transaction_begin() const;
  inline ::operation_msg::Operation_TransactionBegin* mutable_transaction_begin();
  inline ::operation_msg::Operation_TransactionBegin* release_transaction_begin();
  inline void set_allocated_transaction_begin(::operation_msg::Operation_TransactionBegin* transaction_begin);

  // optional .operation_msg.Operation.TransactionEnd transaction_end = 4;
  inline bool has_transaction_end() const;
  inline void clear_transaction_end();
  static const int kTransactionEndFieldNumber = 4;
  inline const ::operation_msg::Operation_TransactionEnd& transaction_end() const;
  inline ::operation_msg::Operation_TransactionEnd* mutable_transaction_end();
  inline ::operation_msg::Operation_TransactionEnd* release_transaction_end();
  inline void set_allocated_transaction_end(::operation_msg::Operation_TransactionEnd* transaction_end);

  // optional .operation_msg.Operation.NoticeError notice_error = 5;
  inline bool has_notice_error() const;
  inline void clear_notice_error();
  static const int kNoticeErrorFieldNumber = 5;
  inline const ::operation_msg::Operation_NoticeError& notice_error() const;
  inline ::operation_msg::Operation_NoticeError* mutable_notice_error();
  inline ::operation_msg::Operation_NoticeError* release_notice_error();
  inline void set_allocated_notice_error(::operation_msg::Operation_NoticeError* notice_error);

  // @@protoc_insertion_point(class_scope:operation_msg.Operation)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_init();
  inline void clear_has_init();
  inline void set_has_transaction_begin();
  inline void clear_has_transaction_begin();
  inline void set_has_transaction_end();
  inline void clear_has_transaction_end();
  inline void set_has_notice_error();
  inline void clear_has_notice_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::operation_msg::Operation_Init* init_;
  ::operation_msg::Operation_TransactionBegin* transaction_begin_;
  ::operation_msg::Operation_TransactionEnd* transaction_end_;
  ::operation_msg::Operation_NoticeError* notice_error_;
  int type_;
  friend void  protobuf_AddDesc_operation_5fmsg_2eproto();
  friend void protobuf_AssignDesc_operation_5fmsg_2eproto();
  friend void protobuf_ShutdownFile_operation_5fmsg_2eproto();

  void InitAsDefaultInstance();
  static Operation* default_instance_;
};
// ===================================================================


// ===================================================================

// Response

// required bool error = 1;
inline bool Response::has_error() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_error() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_error() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_error() {
  error_ = false;
  clear_has_error();
}
inline bool Response::error() const {
  // @@protoc_insertion_point(field_get:operation_msg.Response.error)
  return error_;
}
inline void Response::set_error(bool value) {
  set_has_error();
  error_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Response.error)
}

// required int32 code = 2;
inline bool Response::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 Response::code() const {
  // @@protoc_insertion_point(field_get:operation_msg.Response.code)
  return code_;
}
inline void Response::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Response.code)
}

// optional uint64 transaction_id = 3;
inline bool Response::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 Response::transaction_id() const {
  // @@protoc_insertion_point(field_get:operation_msg.Response.transaction_id)
  return transaction_id_;
}
inline void Response::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Response.transaction_id)
}

// -------------------------------------------------------------------

// Operation_Init

// required string license = 1;
inline bool Operation_Init::has_license() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation_Init::set_has_license() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation_Init::clear_has_license() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation_Init::clear_license() {
  if (license_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_->clear();
  }
  clear_has_license();
}
inline const ::std::string& Operation_Init::license() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.Init.license)
  return *license_;
}
inline void Operation_Init::set_license(const ::std::string& value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_ = new ::std::string;
  }
  license_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.Init.license)
}
inline void Operation_Init::set_license(const char* value) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_ = new ::std::string;
  }
  license_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.Init.license)
}
inline void Operation_Init::set_license(const char* value, size_t size) {
  set_has_license();
  if (license_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_ = new ::std::string;
  }
  license_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.Init.license)
}
inline ::std::string* Operation_Init::mutable_license() {
  set_has_license();
  if (license_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    license_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.Init.license)
  return license_;
}
inline ::std::string* Operation_Init::release_license() {
  clear_has_license();
  if (license_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = license_;
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_Init::set_allocated_license(::std::string* license) {
  if (license_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete license_;
  }
  if (license) {
    set_has_license();
    license_ = license;
  } else {
    clear_has_license();
    license_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.Init.license)
}

// required string app_name = 2;
inline bool Operation_Init::has_app_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation_Init::set_has_app_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation_Init::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation_Init::clear_app_name() {
  if (app_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_name_->clear();
  }
  clear_has_app_name();
}
inline const ::std::string& Operation_Init::app_name() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.Init.app_name)
  return *app_name_;
}
inline void Operation_Init::set_app_name(const ::std::string& value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.Init.app_name)
}
inline void Operation_Init::set_app_name(const char* value) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.Init.app_name)
}
inline void Operation_Init::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_name_ = new ::std::string;
  }
  app_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.Init.app_name)
}
inline ::std::string* Operation_Init::mutable_app_name() {
  set_has_app_name();
  if (app_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    app_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.Init.app_name)
  return app_name_;
}
inline ::std::string* Operation_Init::release_app_name() {
  clear_has_app_name();
  if (app_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = app_name_;
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_Init::set_allocated_app_name(::std::string* app_name) {
  if (app_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete app_name_;
  }
  if (app_name) {
    set_has_app_name();
    app_name_ = app_name;
  } else {
    clear_has_app_name();
    app_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.Init.app_name)
}

// required string language = 3;
inline bool Operation_Init::has_language() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation_Init::set_has_language() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation_Init::clear_has_language() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation_Init::clear_language() {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& Operation_Init::language() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.Init.language)
  return *language_;
}
inline void Operation_Init::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.Init.language)
}
inline void Operation_Init::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.Init.language)
}
inline void Operation_Init::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.Init.language)
}
inline ::std::string* Operation_Init::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.Init.language)
  return language_;
}
inline ::std::string* Operation_Init::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_Init::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.Init.language)
}

// required string language_version = 4;
inline bool Operation_Init::has_language_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation_Init::set_has_language_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation_Init::clear_has_language_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation_Init::clear_language_version() {
  if (language_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_version_->clear();
  }
  clear_has_language_version();
}
inline const ::std::string& Operation_Init::language_version() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.Init.language_version)
  return *language_version_;
}
inline void Operation_Init::set_language_version(const ::std::string& value) {
  set_has_language_version();
  if (language_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_version_ = new ::std::string;
  }
  language_version_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.Init.language_version)
}
inline void Operation_Init::set_language_version(const char* value) {
  set_has_language_version();
  if (language_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_version_ = new ::std::string;
  }
  language_version_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.Init.language_version)
}
inline void Operation_Init::set_language_version(const char* value, size_t size) {
  set_has_language_version();
  if (language_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_version_ = new ::std::string;
  }
  language_version_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.Init.language_version)
}
inline ::std::string* Operation_Init::mutable_language_version() {
  set_has_language_version();
  if (language_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    language_version_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.Init.language_version)
  return language_version_;
}
inline ::std::string* Operation_Init::release_language_version() {
  clear_has_language_version();
  if (language_version_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = language_version_;
    language_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_Init::set_allocated_language_version(::std::string* language_version) {
  if (language_version_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete language_version_;
  }
  if (language_version) {
    set_has_language_version();
    language_version_ = language_version;
  } else {
    clear_has_language_version();
    language_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.Init.language_version)
}

// -------------------------------------------------------------------

// Operation_TransactionBegin

// required string name = 1;
inline bool Operation_TransactionBegin::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation_TransactionBegin::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation_TransactionBegin::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation_TransactionBegin::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Operation_TransactionBegin::name() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.TransactionBegin.name)
  return *name_;
}
inline void Operation_TransactionBegin::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.TransactionBegin.name)
}
inline void Operation_TransactionBegin::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.TransactionBegin.name)
}
inline void Operation_TransactionBegin::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.TransactionBegin.name)
}
inline ::std::string* Operation_TransactionBegin::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.TransactionBegin.name)
  return name_;
}
inline ::std::string* Operation_TransactionBegin::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_TransactionBegin::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.TransactionBegin.name)
}

// -------------------------------------------------------------------

// Operation_TransactionEnd

// required uint64 transaction_id = 1;
inline bool Operation_TransactionEnd::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation_TransactionEnd::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation_TransactionEnd::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation_TransactionEnd::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 Operation_TransactionEnd::transaction_id() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.TransactionEnd.transaction_id)
  return transaction_id_;
}
inline void Operation_TransactionEnd::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Operation.TransactionEnd.transaction_id)
}

// -------------------------------------------------------------------

// Operation_NoticeError

// required uint64 transaction_id = 1;
inline bool Operation_NoticeError::has_transaction_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation_NoticeError::set_has_transaction_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation_NoticeError::clear_has_transaction_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation_NoticeError::clear_transaction_id() {
  transaction_id_ = GOOGLE_ULONGLONG(0);
  clear_has_transaction_id();
}
inline ::google::protobuf::uint64 Operation_NoticeError::transaction_id() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.NoticeError.transaction_id)
  return transaction_id_;
}
inline void Operation_NoticeError::set_transaction_id(::google::protobuf::uint64 value) {
  set_has_transaction_id();
  transaction_id_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Operation.NoticeError.transaction_id)
}

// required string exception_type = 2;
inline bool Operation_NoticeError::has_exception_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation_NoticeError::set_has_exception_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation_NoticeError::clear_has_exception_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation_NoticeError::clear_exception_type() {
  if (exception_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exception_type_->clear();
  }
  clear_has_exception_type();
}
inline const ::std::string& Operation_NoticeError::exception_type() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.NoticeError.exception_type)
  return *exception_type_;
}
inline void Operation_NoticeError::set_exception_type(const ::std::string& value) {
  set_has_exception_type();
  if (exception_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exception_type_ = new ::std::string;
  }
  exception_type_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.NoticeError.exception_type)
}
inline void Operation_NoticeError::set_exception_type(const char* value) {
  set_has_exception_type();
  if (exception_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exception_type_ = new ::std::string;
  }
  exception_type_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.NoticeError.exception_type)
}
inline void Operation_NoticeError::set_exception_type(const char* value, size_t size) {
  set_has_exception_type();
  if (exception_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exception_type_ = new ::std::string;
  }
  exception_type_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.NoticeError.exception_type)
}
inline ::std::string* Operation_NoticeError::mutable_exception_type() {
  set_has_exception_type();
  if (exception_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    exception_type_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.NoticeError.exception_type)
  return exception_type_;
}
inline ::std::string* Operation_NoticeError::release_exception_type() {
  clear_has_exception_type();
  if (exception_type_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = exception_type_;
    exception_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_NoticeError::set_allocated_exception_type(::std::string* exception_type) {
  if (exception_type_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete exception_type_;
  }
  if (exception_type) {
    set_has_exception_type();
    exception_type_ = exception_type;
  } else {
    clear_has_exception_type();
    exception_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.NoticeError.exception_type)
}

// required string error_message = 3;
inline bool Operation_NoticeError::has_error_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation_NoticeError::set_has_error_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation_NoticeError::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation_NoticeError::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& Operation_NoticeError::error_message() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.NoticeError.error_message)
  return *error_message_;
}
inline void Operation_NoticeError::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.NoticeError.error_message)
}
inline void Operation_NoticeError::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.NoticeError.error_message)
}
inline void Operation_NoticeError::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.NoticeError.error_message)
}
inline ::std::string* Operation_NoticeError::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    error_message_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.NoticeError.error_message)
  return error_message_;
}
inline ::std::string* Operation_NoticeError::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_NoticeError::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.NoticeError.error_message)
}

// required string stack_trace = 4;
inline bool Operation_NoticeError::has_stack_trace() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation_NoticeError::set_has_stack_trace() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation_NoticeError::clear_has_stack_trace() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation_NoticeError::clear_stack_trace() {
  if (stack_trace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_trace_->clear();
  }
  clear_has_stack_trace();
}
inline const ::std::string& Operation_NoticeError::stack_trace() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.NoticeError.stack_trace)
  return *stack_trace_;
}
inline void Operation_NoticeError::set_stack_trace(const ::std::string& value) {
  set_has_stack_trace();
  if (stack_trace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_trace_ = new ::std::string;
  }
  stack_trace_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.NoticeError.stack_trace)
}
inline void Operation_NoticeError::set_stack_trace(const char* value) {
  set_has_stack_trace();
  if (stack_trace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_trace_ = new ::std::string;
  }
  stack_trace_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.NoticeError.stack_trace)
}
inline void Operation_NoticeError::set_stack_trace(const char* value, size_t size) {
  set_has_stack_trace();
  if (stack_trace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_trace_ = new ::std::string;
  }
  stack_trace_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.NoticeError.stack_trace)
}
inline ::std::string* Operation_NoticeError::mutable_stack_trace() {
  set_has_stack_trace();
  if (stack_trace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_trace_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.NoticeError.stack_trace)
  return stack_trace_;
}
inline ::std::string* Operation_NoticeError::release_stack_trace() {
  clear_has_stack_trace();
  if (stack_trace_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stack_trace_;
    stack_trace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_NoticeError::set_allocated_stack_trace(::std::string* stack_trace) {
  if (stack_trace_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stack_trace_;
  }
  if (stack_trace) {
    set_has_stack_trace();
    stack_trace_ = stack_trace;
  } else {
    clear_has_stack_trace();
    stack_trace_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.NoticeError.stack_trace)
}

// required string stack_frame_delimiter = 5;
inline bool Operation_NoticeError::has_stack_frame_delimiter() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Operation_NoticeError::set_has_stack_frame_delimiter() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Operation_NoticeError::clear_has_stack_frame_delimiter() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Operation_NoticeError::clear_stack_frame_delimiter() {
  if (stack_frame_delimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_frame_delimiter_->clear();
  }
  clear_has_stack_frame_delimiter();
}
inline const ::std::string& Operation_NoticeError::stack_frame_delimiter() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.NoticeError.stack_frame_delimiter)
  return *stack_frame_delimiter_;
}
inline void Operation_NoticeError::set_stack_frame_delimiter(const ::std::string& value) {
  set_has_stack_frame_delimiter();
  if (stack_frame_delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_frame_delimiter_ = new ::std::string;
  }
  stack_frame_delimiter_->assign(value);
  // @@protoc_insertion_point(field_set:operation_msg.Operation.NoticeError.stack_frame_delimiter)
}
inline void Operation_NoticeError::set_stack_frame_delimiter(const char* value) {
  set_has_stack_frame_delimiter();
  if (stack_frame_delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_frame_delimiter_ = new ::std::string;
  }
  stack_frame_delimiter_->assign(value);
  // @@protoc_insertion_point(field_set_char:operation_msg.Operation.NoticeError.stack_frame_delimiter)
}
inline void Operation_NoticeError::set_stack_frame_delimiter(const char* value, size_t size) {
  set_has_stack_frame_delimiter();
  if (stack_frame_delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_frame_delimiter_ = new ::std::string;
  }
  stack_frame_delimiter_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:operation_msg.Operation.NoticeError.stack_frame_delimiter)
}
inline ::std::string* Operation_NoticeError::mutable_stack_frame_delimiter() {
  set_has_stack_frame_delimiter();
  if (stack_frame_delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stack_frame_delimiter_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.NoticeError.stack_frame_delimiter)
  return stack_frame_delimiter_;
}
inline ::std::string* Operation_NoticeError::release_stack_frame_delimiter() {
  clear_has_stack_frame_delimiter();
  if (stack_frame_delimiter_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stack_frame_delimiter_;
    stack_frame_delimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Operation_NoticeError::set_allocated_stack_frame_delimiter(::std::string* stack_frame_delimiter) {
  if (stack_frame_delimiter_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stack_frame_delimiter_;
  }
  if (stack_frame_delimiter) {
    set_has_stack_frame_delimiter();
    stack_frame_delimiter_ = stack_frame_delimiter;
  } else {
    clear_has_stack_frame_delimiter();
    stack_frame_delimiter_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.NoticeError.stack_frame_delimiter)
}

// -------------------------------------------------------------------

// Operation

// required .operation_msg.Operation.OperationType type = 1;
inline bool Operation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::operation_msg::Operation_OperationType Operation::type() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.type)
  return static_cast< ::operation_msg::Operation_OperationType >(type_);
}
inline void Operation::set_type(::operation_msg::Operation_OperationType value) {
  assert(::operation_msg::Operation_OperationType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:operation_msg.Operation.type)
}

// optional .operation_msg.Operation.Init init = 2;
inline bool Operation::has_init() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Operation::set_has_init() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Operation::clear_has_init() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Operation::clear_init() {
  if (init_ != NULL) init_->::operation_msg::Operation_Init::Clear();
  clear_has_init();
}
inline const ::operation_msg::Operation_Init& Operation::init() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.init)
  return init_ != NULL ? *init_ : *default_instance_->init_;
}
inline ::operation_msg::Operation_Init* Operation::mutable_init() {
  set_has_init();
  if (init_ == NULL) init_ = new ::operation_msg::Operation_Init;
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.init)
  return init_;
}
inline ::operation_msg::Operation_Init* Operation::release_init() {
  clear_has_init();
  ::operation_msg::Operation_Init* temp = init_;
  init_ = NULL;
  return temp;
}
inline void Operation::set_allocated_init(::operation_msg::Operation_Init* init) {
  delete init_;
  init_ = init;
  if (init) {
    set_has_init();
  } else {
    clear_has_init();
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.init)
}

// optional .operation_msg.Operation.TransactionBegin transaction_begin = 3;
inline bool Operation::has_transaction_begin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Operation::set_has_transaction_begin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Operation::clear_has_transaction_begin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Operation::clear_transaction_begin() {
  if (transaction_begin_ != NULL) transaction_begin_->::operation_msg::Operation_TransactionBegin::Clear();
  clear_has_transaction_begin();
}
inline const ::operation_msg::Operation_TransactionBegin& Operation::transaction_begin() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.transaction_begin)
  return transaction_begin_ != NULL ? *transaction_begin_ : *default_instance_->transaction_begin_;
}
inline ::operation_msg::Operation_TransactionBegin* Operation::mutable_transaction_begin() {
  set_has_transaction_begin();
  if (transaction_begin_ == NULL) transaction_begin_ = new ::operation_msg::Operation_TransactionBegin;
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.transaction_begin)
  return transaction_begin_;
}
inline ::operation_msg::Operation_TransactionBegin* Operation::release_transaction_begin() {
  clear_has_transaction_begin();
  ::operation_msg::Operation_TransactionBegin* temp = transaction_begin_;
  transaction_begin_ = NULL;
  return temp;
}
inline void Operation::set_allocated_transaction_begin(::operation_msg::Operation_TransactionBegin* transaction_begin) {
  delete transaction_begin_;
  transaction_begin_ = transaction_begin;
  if (transaction_begin) {
    set_has_transaction_begin();
  } else {
    clear_has_transaction_begin();
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.transaction_begin)
}

// optional .operation_msg.Operation.TransactionEnd transaction_end = 4;
inline bool Operation::has_transaction_end() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Operation::set_has_transaction_end() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Operation::clear_has_transaction_end() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Operation::clear_transaction_end() {
  if (transaction_end_ != NULL) transaction_end_->::operation_msg::Operation_TransactionEnd::Clear();
  clear_has_transaction_end();
}
inline const ::operation_msg::Operation_TransactionEnd& Operation::transaction_end() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.transaction_end)
  return transaction_end_ != NULL ? *transaction_end_ : *default_instance_->transaction_end_;
}
inline ::operation_msg::Operation_TransactionEnd* Operation::mutable_transaction_end() {
  set_has_transaction_end();
  if (transaction_end_ == NULL) transaction_end_ = new ::operation_msg::Operation_TransactionEnd;
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.transaction_end)
  return transaction_end_;
}
inline ::operation_msg::Operation_TransactionEnd* Operation::release_transaction_end() {
  clear_has_transaction_end();
  ::operation_msg::Operation_TransactionEnd* temp = transaction_end_;
  transaction_end_ = NULL;
  return temp;
}
inline void Operation::set_allocated_transaction_end(::operation_msg::Operation_TransactionEnd* transaction_end) {
  delete transaction_end_;
  transaction_end_ = transaction_end;
  if (transaction_end) {
    set_has_transaction_end();
  } else {
    clear_has_transaction_end();
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.transaction_end)
}

// optional .operation_msg.Operation.NoticeError notice_error = 5;
inline bool Operation::has_notice_error() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Operation::set_has_notice_error() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Operation::clear_has_notice_error() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Operation::clear_notice_error() {
  if (notice_error_ != NULL) notice_error_->::operation_msg::Operation_NoticeError::Clear();
  clear_has_notice_error();
}
inline const ::operation_msg::Operation_NoticeError& Operation::notice_error() const {
  // @@protoc_insertion_point(field_get:operation_msg.Operation.notice_error)
  return notice_error_ != NULL ? *notice_error_ : *default_instance_->notice_error_;
}
inline ::operation_msg::Operation_NoticeError* Operation::mutable_notice_error() {
  set_has_notice_error();
  if (notice_error_ == NULL) notice_error_ = new ::operation_msg::Operation_NoticeError;
  // @@protoc_insertion_point(field_mutable:operation_msg.Operation.notice_error)
  return notice_error_;
}
inline ::operation_msg::Operation_NoticeError* Operation::release_notice_error() {
  clear_has_notice_error();
  ::operation_msg::Operation_NoticeError* temp = notice_error_;
  notice_error_ = NULL;
  return temp;
}
inline void Operation::set_allocated_notice_error(::operation_msg::Operation_NoticeError* notice_error) {
  delete notice_error_;
  notice_error_ = notice_error;
  if (notice_error) {
    set_has_notice_error();
  } else {
    clear_has_notice_error();
  }
  // @@protoc_insertion_point(field_set_allocated:operation_msg.Operation.notice_error)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace operation_msg

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::operation_msg::Operation_OperationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operation_msg::Operation_OperationType>() {
  return ::operation_msg::Operation_OperationType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_operation_5fmsg_2eproto__INCLUDED
